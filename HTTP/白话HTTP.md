# 白话HTTP协议

在浏览器的地址栏输入一个地址：`https://meili.github.io/min/index.html`，回车，浏览器就会向该地址对应的服务器发出一个**请求**，服务器接收到请求后向浏览器返回**响应**对应的网页。浏览器（下文统称为客户端）和服务器之间的这次通信是遵循HTTP协议的。

因此，我的理解是HTTP协议规定了客户端与服务器之间通信格式。

《HTTP权威指南》中的定义：

> HTTP（Hypertext Transfer Protocol，超文本传输协议）是在万维网上进行通信时所使用的协议方案。

本文又臭又长，先祭出一张思维导图交代清楚我到底乱七八糟说了啥：

![image](https://github.com/Misszhu/myblog/raw/master/HTTP/image/HTTP1.png)

### 客户端和服务器

我们约定，服务器是存储资源的一端，客户端是发送请求的一端，在上面的例子中，浏览器就是客户端，我们想访问的网页存储在服务器。

### URL & URI

要访问存储在服务器中的资源，就需要预先知道去什么地方这个资源。比如，有了地址：`http://www.joes-hardware.com/specials/saw-blade.gif`，我们就知道去「www.joes-hardware.com」这台服务器（这里只是简略说明）的`/specials`路径找名称为`saw-blade.gif`的图片。**URL**就是地址。URL的全称是**统一资源定位符**（英语：**U**niform **R**esource **L**ocator）。

说到URL，还有一个不得不提的概念，叫**URI**。URI的全称是**统一资源标识符**（英语：**U**niform **R**esource **I**dentifier）。URI是某个资源在服务器（或者说互联网上）的唯一标识。

URL是URI的其中一种实现形式。什么意思呢？先看一个假想的场景：

警察要找一个人，第一种方法是通过这个人的家庭地址去找，第二种方法是通过这个人的身份证号去找。回到网络世界，客户端拿着唯一标识URL（地址），要去服务器找一张图片。在这种情况下，URI的实现形式就是URL（即用地址（URL）作为这张图片的唯一标识）。

在现实世界中，几乎所有的URI都是URL，并不需要对URL和URI进行严格的区分。下面是URL的完整结构：

![image](https://github.com/Misszhu/myblog/raw/master/HTTP/image/HTTP2.png)

| 关键字   | 解释                                                         |
| -------- | ------------------------------------------------------------ |
| 协议     | 规定客户端与服务器之间的数据通信格式，最常用的就是HTTP & HTTPS |
| 域名     | 表明正在请求哪个服务器，也可以直接用IP地址                   |
| 端口     | 可以理解成**入口：**在目标服务器的什么地方可以找到对应的资源， |
| 路径     | 服务器上资源的具体路径                                       |
| 额外参数 | 通过指名具体的额外参数，可以缩小请求资源类型的范围           |
| 锚点     | 资源片段。比如，访问资源的URL会指向整个HTML文档，而有了锚点，就能指向一个特定的图片或小节。 |

把URL类比成快递地址可能会更好理解它的结构：协议表示送快递时需要遵循的规则（运输方式、运输物品限制等等）；域名（即服务器、IP表示）表示某个具体的地点，比如广州市海珠区新滘中路；端口表示入口，比如（新滘中路的）88号；路径则可以类比成更详细的地址信息：哪一栋；参数则提供额外的信息，比如哪一层的xx地方。

这里需要注意的是，锚点，即资源片段：资源片段是不发送给服务器的，服务器通常只处理整个对象，通常是客户端获取到整个资源后，显示我们感兴趣的片段。

### 事务

有了URL，客户端就知道要去哪一台服务器的什么地方获取什么资源，服务器接收到客户端的请求后再返回对应的资源给客户端。由此，我们就引出了一个新的概念：一个**HTTP事务**由一条（从客户端发往服务器的）请求命令和一个（从服务器发回客户端的）响应结果组成。

**HTTP报文**就是描述**HTTP事务**的格式化数据块。

### HTTP报文

从客户端发往服务器的HTTP报文成为请求报文，从服务器发往客户端的报文成为响应报文。

HTTP报文的组成结构如下：

- 起始行

  ​	报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况。

- 首部

  ​	格式化的键值对，也就是我们常说的request headers 和 response headers，用来描述请求或者响应的一些信息，可读写。

- 实体

  ​	又叫报文主体，可选的。请求的主体中包括了要发送给服务器的数据（即我们经常讲的请求body）；响应主体中装载了返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，主体中可以包含任意的二进制数据（比如图片、视频、音频等）。当然主体中也可以包含文本。

看一个简单的报文实例：

浏览器打开百度首页www.baidu.com（请求百度首页的HTML资源，数据量很大，删减了大部分报文数据，只作展示用）：

![image](https://github.com/Misszhu/myblog/raw/master/HTTP/image/HTTP3.png)在上图中，浏览器发送了一条HTTP请求报文，起始行有个GET命令，表明该请求使用GET方法获取资源，资源对应的位置在 `/`，HTTP协议版本号为1.1。GET请求报文没有主体。

服务器会返回一条HTTP响应报文。响应起始行也包含了HTTP协议版本号、一个成功状态码（200）以及一个描述性的原因短语（OK）。响应首部字段描述了响应主体的详细信息：其中**Content-Type**首部说明了响应主体的MIME类型，**Date**首部说明了响应的时间。在响应起始行和响应首部后面跟着的就是响应主体。

#### **起始行**

请求报文起始行的格式：<method> <request-URL  or path> <version>

响应报文起始行的格式：<version> <status> <reason-phrase>

重点说一下请求方法 (method) 和 状态码 (status-code)。

**方法 method**

方法 method 表示客户端希望服务器对资源执行的动作。下表展示了常用的HTTP请求方法以及他们的相关信息：

| 方法    | 描述                                               | 是否包含主体 |
| ------- | -------------------------------------------------- | ------------ |
| GET     | 从服务器获取一份文档（查询）                       | 否           |
| HEAD    | 只从服务器获取文档的首部                           | 否           |
| POST    | 向服务器发送需要处理的数据                         | 是           |
| PUT     | 对服务器的文档进行修改                             | 是           |
| TRACE   | 对可能经过代理服务器传送到目标服务器的报文进行追踪 | 否           |
| OPTIONS | 决定可以在服务器上执行哪些方法                     | 否           |
| DELETE  | 从服务器上删除一份文档                             | 否           |

GET方法通常用于查询操作。

HEAD方法和GET方法的行为很类似，但服务器在响应中只返回首部，不返回实体的主体部分（即只返回response headers，不返回response body）。对响应的首部进行检查，可以：

- 在不获取资源的情况下了解资源的信息（比如，判断其类型）；
- 通过查看响应中的状态码，看看某个对象是否存在；
- 通过查看首部，测试资源是否被修改了。

我理解的PUT方法则是用来修改服务器中的特定数据。比如在restful架构中，PUT被用来做修改操作。

POST方法用来向服务器输入数据，比如提交表单、插入数据等等。

TRACE方法用于诊断：客户端发起一个请求时，这个请求可能要通过防火墙、代理、网关或者其他一些应用程序，每个中间节点都可能会修改原始的HTTP请求。TRACE方法允许客户端在最终将请求发送到服务器时，看看它变成了什么样子。

OPTIONS方法可以用来询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。

DELETE方法所做的事情就是请求服务器删除请求URL所指定的资源。

**状态码**

方法是用来告诉服务器做什么事情的，状态码则用来告诉客户端，发生了什么事情，或者说服务器是如何应答来自客户端的请求的。

HTTP状态码是有分类的，某一个范围的状态码表示不同类型的返回：

| 范围      | 分类       |
| --------- | ---------- |
| 100 ~ 199 | 信息提示   |
| 200 ~ 299 | 成功       |
| 300 ~ 399 | 重定向     |
| 400 ~ 499 | 客户端错误 |
| 500 ~ 599 | 服务器错误 |

下面列出常见状态码及其含义：

| 状态码 | 原因短语                   | 含义                                                         |
| ------ | -------------------------- | ------------------------------------------------------------ |
| 200    | OK                         | 请求成功                                                     |
| 301    | Move Permanently           | 被请求的资源已永久移动到新位置                               |
| 304    | Not Modified               | 未改变，说明无需再次传输请求的内容，也就是可以使用缓存内容。通常都是在GET 或者 HEAD请求带上了头部信息：If-None-Match 或If-Modified-Since。 |
| 401    | Unauthorized               | 当前的请求需要用户验证，可以理解为需要用户凭证。             |
| 403    | Forbidden                  | 代表客户端错误，指的是服务器有能力处理该请求，但是拒绝授权访问。 |
| 404    | Not Found                  | 请求希望得到的资源未被找到，一般是URL错误导致的。            |
| 405    | Method Not Allow           | 请求所指定的方法不能被用于请求相应的资源。                   |
| 500    | Internal Server Error      | 服务器遇到了未知错误。                                       |
| 501    | Not Implemented            | 请求的方法不被服务器支持。                                   |
| 502    | Bad Gateway                | （作为网关或者代理工作的服务器）从上游服务器接收到无效的响应。 |
| 503    | Service Unavailable        | 服务器还没准备好处理请求。常见原因是服务器因维护或重载而停机。 |
| 504    | Gateway Timeout            | （作为网关或者代理工作的服务器）未能及时从上游服务器收到响应 |
| 505    | HTTP Version Not Supported | 服务器不支持请求中所使用的HTTP协议版本                       |

#### 首部

日常开发中常常提到的“请求头、header”就是首部。HTTP首部字段向请求和响应报文中添加一些附件信息。本质上，首部字段只是一些键值对。HTTP首部可以分为以下几类：

- 通用首部

  ​	既可以出现在请求报文中，也可以出现在响应报文中。

- 请求首部

  ​	提供更多有关请求的信息。

- 响应首部

  ​	提供更多有关响应的信息

- 实体首部

  ​	描述主体的长度和内容，或者资源自身

- 扩展首部

  ​	规范中没有定义的新首部

常见的首部实例：

| 首部字段                                     | 描述                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| **Date:** Wed, 28 Oct 2020 07:30:16 GMT      | 服务器产生响应的日期                                         |
| **Content-length:** 15040                    | 实体的主体部分包含了15040字节的数据                          |
| **Content-type:** image/gif                  | 实体的主体部分是一个GIF图片                                  |
| **Accept:** image/gif, image/jpeg, text/html | 客户端可以接收GIF图片和JPEG图片及HTML                        |
| **Authorization:** xxxx                      | 服务器用于验证用户身份的凭证，通常如果服务器需要验证用户身份，就要在该字段带上身份凭证，否则服务器返回401 Unauthorized |
| **Accept-Encoding:** gzip, deflate, br       | 客户端可以接受这些压缩方法：gzip, deflate, br                |
| **Content-Encoding:** gzip                   | 说明实体数据的压缩方法                                       |

### 实体

我把实体理解成HTTP真正传输的数据。HTTP请求报文的实体是客户端发送给服务器的真正数据，HTTP响应报文的实体是服务器返回给客户端的数据。

如果把HTTP通信请求与返回的过程想象送快递和回赠快递的过程，HTTP协议就是快递公司员工需要遵守的规章制度，URL是收货地址，HTTP报文是装货物的箱子，请求行和首部是箱子上面的一些信息，实体就是真正的货物。

同理，请求实体是送出去的“货物”，响应实体则是回赠的“货物”。

说到这里，我们就很容易理解，为什么HTTP协议规定只有POST请求和PUT请求的请求报文有实体。比如GET请求只是做查询操作，没有必须有请求实体，如果想要在请求过程中向服务器发送实体数据，直接用POST请求即可。

#### 实体的大小

Content-length 首部标明实体主体的字节大小。这个大小是包含了所有内容编码的。比如，对文本文件进行了gzip压缩的话，Content-Length首部就是压缩后的大小，而不是原始大小。使用Content-length首部是为了能够检测出服务器崩溃而导致的报文截尾。

#### 实体的MIME类型

Content-Type首部说明的是原始实体主体的媒体类型。例如，如果实体经过内容编码的话，Content-Type首部说明的仍是编码之前的实体主体的类型。

### 总结

我通过简单剖析URL以及HTTP报文的结构，简单理解了一个HTTP请求过程。我上面所写的内容只是皮毛，但是对我日常开发来说这些知识暂时够用了，至少不用再和同事争论get请求到底能不能发送body这种蠢问题。

HTTP是一个很大的课题，《HTTP权威指南》实体书有720页，虽然比砖头还厚，但涵盖了HTTP的方方面面，想要深入了解HTTP的朋友可以去阅读这本书。我在写这篇文章的时候也反复了阅读书中的某一些章节。如果你在阅读的过程中对某些地方存疑，肯定是我错了，接受任何反驳~

参考：

> 《HTTP权威指南》
>
> [URL—维基百科](https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6)
>
> [What_is_a_URL](https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_URL)
>
> [HTTP状态码—MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)
>
> [HTTP Headers— MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers)
>
> [HTTP协议入门—阮一峰](http://www.ruanyifeng.com/blog/2016/08/http.html)
