# 6. 正则表达式的构建

我们已经学习了正则的一些知识点，也学会了如何去拆分别人写好的正则。这次和大家分享构建一个合适的正则表达式的注意要点：

- 平衡法则
- 构建正则的前提
- 准确性
- 效率

## 6.1平衡法则

构建正则有一点非常重要，需要做到下面几点平衡：

- 匹配预期的字符串
- 不匹配非预期的字符串
- 可读性和可维护性
- 效率

## 6.2构建正则前提

### **6.2.1 是否能使用正则**

虽然是正则很强大的，但并非万物皆可正则。正则可以匹配的字符肯定能符合正则所能描述的某种规则。比如斐波那契数列：

0、1、1、2、3、5、8、13、21、34……

虽然这个数列有它自己的规律，但这不是正则能匹配的。

### **6.2.2 是否有必要使用正则**

正则有它的不可替代之处，但在某些场景下借助JavaScript内置的API可能比正则更直观。

从日期中提取年月入，正则的处理方式为：

```javascript
var string = "2017-07-01";
var regex = /^(\d{4})-(\d{2})-(\d{2})/;
console.log( string.match(regex) );
// => ["2017-07-01", "2017", "07", "01", index: 0, input: "2017-07-01"]
```

也可以用`String.prototype.split()`提取：

```javascript
var string = "2017-07-01";
var result = string.split("-"); console.log( result );
 // => ["2017", "07", "01"]
```

再比如获取子串，正则的处理方式为：

```javascript
var string = "JavaScript";
console.log( string.match(/.{4}(.+)/)[1] ); // => Script
```

用`String.prototype.subString()`亦可：

```javascript
var string = "JavaScript"; 
console.log( string.substring(4) ); // => Script
```

### **6.2.3 是否有必要构建一个复杂的正则**

前面我们做过用匹配密码的案例：6 到 12位，至少包含数字、大写字母和大写字母中的任意两种.

正则表达式为：`/((?=.*\d)(?=.*[a-z])|(?=.*\d)(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]{6,12}$/`

上面正则可以拆分成多个小正则：

```javascript
var regex1 = /^[0-9A-Za-z]{6,12}$/;
var regex2 = /^[0-9]{6,12}$/;
var regex3 = /^[A-Z]{6,12}$/;
var regex4 = /^[a-z]{6,12}$/; 
function checkPassword (string) {
 if (!regex1.test(string)) return false; 
 if (regex2.test(string)) return false; 
 if (regex3.test(string)) return false;
 if (regex4.test(string)) return false; 
 return true;
}
```

在实际开发中大部分人一般会选择使用复杂的匹配密码的正则表达式，毕竟节省了10行的代码呀！但不可否认的是拆分后的demo可读性更高。

## 6.3 准确性

所谓准确性，就是匹配预期的字符串，不匹配非预期的字符串。

既然是需要匹配预期的字符串，那我们就要先梳理出目标字符串的规则。

### **6.3.1 匹配浮点数**

要求匹配如下格式的浮点数：

```javascript
1.23、+1.23、-1.23 
10、+10、-10 
.2、+.2、-.2
```

我们很容易就可以总结出浮点数能被拆分成以下三部分：

1. 符号部分：`[+-]`
2. 整数部分：`\d+`
3. 小数部分：`\.\d+`

对于一个”合法“的浮点数来说，符号、整数部分、小数部分都不是必需的，因此完整的正则是：

```javascript
/^[+-]?(\d+)?(\.\d+)?$/
```

可视化形式：

<img src="https://github.com/Misszhu/myblog/raw/master/image/structure1.png" alt="image" style="zoom:80%;" />这个正则能匹配合法的浮点数，但是它也会匹配空字符。那换一个思路：

1. 匹配只有整数部分的浮点数：`/^[+-]?\d+$/`
2. 匹配只有小数部分的浮点数：`/^[+-]?\.\d+$/`
3. 匹配同时含有整数部分和小数部分的浮点数：`/^[+-]?\d+\.\d+$/`

这里用到分支结构，提取公共部分稍作优化：

```javascript
/^[+-]?(\d+\.\d+|\.\d+|\d+)$/
```

可视化形式为：

<img src="https://github.com/Misszhu/myblog/raw/master/image/structure2.png" alt="image" style="zoom:80%;" />

如果不想匹配只有小数部分但是又有符号目标字符串，比如：+0.2，-0.2，可以把上面正则修改为：

`/^([+-]?(\d+\.\d+|\d+)|\.\d+)$/`

可视化形式为：

<img src="https://github.com/Misszhu/myblog/raw/master/image/structure3.png" alt="image" style="zoom:80%;" />

其实这个正则也不是完美的，他会匹配'012'、'0'这样的整数。如果要求不能匹配这种整数的话，我们还要继续修改~是不是感觉走走进了一个圈套？思路缜密的朋友在匹配之前，一般会对目标字符串进行判空和trim处理，所以一开始写的`/^[+-]?(\d+)?(\.\d+)?$/`似乎也够用了。

说了这么多，是为了跟大家说明，虽然我们的目的是准确性，但是往往不存在百分百完美的解决方法。我们在可读性、准确性、可维护性之间找到平衡点，写出来的正则就是好正则。

## 6.4 效率

保证了准确性之后，就需要考虑如何优化，这里指的优化是提高匹配的效率。而需要提高效率，就要先了解正则表达式的运行过程。

正则表达式的运行过程分为如下阶段：

<img src="https://github.com/Misszhu/myblog/raw/master/image/structure4.png" alt="image" style="zoom:80%;" />

下面以代码为例，来看看这几个阶段都做了什么。示例代码：

```javascript
var regex = /\d+/g;
var string = "123abc456def";
console.log(regex.lastIndex, regex.exec(string)) //0 ["123", index: 0, input: "123abc456def", groups: undefined]
console.log(regex.lastIndex, regex.exec(string)) //3 ["456", index: 6, input: "123abc456def", groups: undefined]
console.log(regex.lastIndex, regex.exec(string)) //9 null
console.log(regex.lastIndex, regex.exec(string)) //0 ["123", index: 0, input: "123abc456def", groups: undefined]
```

具体分析如下：

**阶段一：当生成一个正则时，引擎会对其进行编译。报错与否出现在这个阶段。**

理论上，编译完成之后就可以开始匹配，不过在正则中有一个概念叫 **起始位置——RegExp.lastIndex**。也就是说，需要告诉引擎从哪个位置开始匹配。默认情况下，起始位置是0，即从目标字符串的第0位开始匹配。

> `g`是正则表达式的全局匹配符，表示在目标字符串中按顺序找到满足匹配模式的所有子串，强调所有，而不是一个。`g`是global的缩写。
>
> 如果正则使用了全局标识符 g，并且多次执行RegExp.prototype.exec() 或者 RegExp.prototype.test()时，每找到一个满足匹配模式的子串，正则的lastIndex会同时被更新为这个子串结束位置下一位，下一次匹配将从lastIndex属性指定的位置开始。注意，即使前后的目标字符串不是同一个，lastIndex也不会被重置，它依旧会从记录的lastIndex开始。

结合示例代码感受一下：

1. 默认lastIndex为0，所以打印的lastIndex为0，第一次执行exec方法，匹配到的子串为'123';
2. 同时引擎会记住匹配结束的位置为2，所以第二次打印的lastIndex为3；
3. 第二次执行exec方法，从第三位开始，往下寻找能满足匹配模式的子串，a不满足，那往下走，从下一位开始重新匹配，b、c同理；
4. 接着遇到4，匹配了子串'456'，lastIndex变成了9;
5. 第三次执行exec方法，剩余的子串都不满足匹配，返回null；
6. 整个目标字符串都匹配完成之后，lastIndex被重置为0。

当正则使用全局标识符时，会更新lastIndex这个很好理解，就像平时找东西一样，某一个地方找过了，我们就会给标记一下这个地方，表示已经找过了，lastIndex在这里的也是标记的意思。

对正则的匹配过程有了大致的了解后，我们可以考虑基于效率来优化正则。

### 6.4.1 **使用具体型字符组来替代通配符**

比如前面我们试过用`/".*"/`来匹配"abb"bc，产生了3次回溯：

<img src="https://github.com/Misszhu/myblog/raw/master/image/structure5.png" alt="image" style="zoom:80%;" />

如果正则用`/".*?"/`，也会产生2次回溯：

<img src="https://github.com/Misszhu/myblog/raw/master/image/structure6.png" alt="image" style="zoom:80%;" />

可能有人对惰性量词也会产生回溯感到奇怪，解释一下：由于用了惰性量词，`.*`匹配了一个字符a之后，就会开始对剩余的'"'`的匹配，如果有字符'"'，匹配完成，引擎就会停止匹配，但实际上遇到的是字符'b'，引擎只能后退一步，用 .* 去匹配字符 b。接着重复上面的步骤，直到遇到字符'"'。

因此，我们不难猜测，由于回溯的存在，引擎在匹配过程中需要将尝试过的状态保存起来，以便后续的回溯使用，这就要消耗一定的内存。那我们可以使用具体型的字符组来代替通配符，即`/"[^"]*"/`。

### **6.4.2 使用非捕获型分组**

括号的作用之一就是捕获分组和分组里面的数据，那么保存数据必然需要内存。如果我们不需要提取数据时，就可以使用非捕获型分组：

`/(?:ab)+/`

### **6.4.3 独立出确定字符**

为了提高效率，我们还可以将`/a+/`优化为`/aa*/`。后者比前者多了一个确定的字符a，能在匹配时加快移位的速度

### **6.4.4 提取分支的公共部分**

受独立出确定字符的启发，我们也可以通过提取分支的公共部分，以加快移位的速度：`this|that`优化为`th(?:is|at)`

### **6.4.5 减少分支的数量**

`read|red`优化为`rea?d`

分支和量词产生回溯的成本不一样。这里用量词取代分支结构只是一个示例，并不是每一个分支结构都能用两次改造的。这样优化后，可读性会降低，真正用到事，根据实际情况进行取舍即可。

## 6.5 本章小结

本章讲的是构建正则时的一些注意要点。没有100%完美的正则，正如没有100%完美的代码一样。这里旨在给大家提供一个思路：在构建正则时在准确性、可读性找到平衡即可。正则有他的局限性，但我们也没必要因噎废食，因为这样就不用正则，正则依然是非常强大的，最重要的是我们在理清了正则的知识点之后，多写多用，用正则做一些很酷的事情。

